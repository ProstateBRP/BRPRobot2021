clc;
clear;

%Initialzation and setup for parameters
server = Server('simulation', true);
server.connect();
calibration_finsh_flag = false;
planning_finsh_flag = false;
targeting_finsh_flag = false;
target_not_reachable = false;
idle_flag = false;
command_recieved = false;
% Must determine control type!
open_loop = true;
%Robot setup and bring up
robot_not_ready = server.robot.is_startup();
robot_pose = server.robot.get_robot_current_pose();     

% Todo: add parral robot state sender in state changing phase?

%The main function loop; Missing a robot state update server thread.
while true
    if ~idle_flag && ~command_recieved
        [name, state] = server.receiver.readCommandMessage();

    end
    %
    switch state
        case "START_UP"
            disp('Start_up');
            start_up_count = 0;
            id = split(name, '_');
            server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
            if robot_not_ready
                % Start up the robot
                server.robot.startup();
                robot_not_ready = server.robot.is_startup();
                %if it's started or not, wait for it to start up
                if robot_not_ready
                    status = struct('code', 13, 'subCode', 13, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                    error_message = "Start up fail, check robot status";
                    disp(error_message)
                else
                    status = struct('code', 1, 'subCode', 1, 'errorName', 'none', 'message', 'STATUS_OK');
                    server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                end
                status = struct('code', 1, 'subCode', 1, 'errorName', 'none', 'message', 'STATUS_OK');
                server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
            end
            if command_recieved
                disp('Already started up');
                command_recieved = false;
            end                           
                idle_flag = true;
                state = "IDLE";        
                server.robot.set_robot_mode('idle');

        case "CALIBRATION"
            disp('Calibration');
            %First Check if robot has started up
            fail_flag = false;
            id = split(name, '_');
            robot_mode = server.robot.check_robot_mode();
            if ~robot_not_ready 
                server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
                % Set the robot into calibration mode
                if ~strcmp(robot_mode, 'calibration')
                    %try to set the robot mode in calibration
                    server.robot.set_robot_mode('calibration');
                    robot_mode = server.robot.check_robot_mode();               
                    if ~strcmp(robot_mode, 'calibration')
                        status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                        error_message = "Start Calibration fail, check robot status, back to IDLE.";
                        disp(error_message);
                        fail_flag = true;
                    else
                        status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                    end
                    server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                end

                if ~fail_flag
                    while ~calibration_finsh_flag
                        [head, type, data] = server.receiver.readMessage();
                        id = split(name, '_');
                        if strcmpi(type, 'STRING')
                            if strcmpi(data, 'CURRENT_POSITION')
                                robot_pose = server.robot.get_robot_current_pose();
                                server.sender.WriteOpenIGTLinkTransformMessage(char("CURRENT_POSITION"), robot_pose);
                                pause(0.2);
                            else
                                error_message = "Wrong command at this time.";
                                server.sender.WriteOpenIGTLinkStringMessage(char(name), char(error_message));
                            end
                        elseif strcmpi(type, 'TRANSFORM')
                            server.sender.WriteOpenIGTLinkTransformMessage(char("ACK_Transform"), data);
                            calibration_finsh_flag = server.robot.calibrate(data);
                            if ~calibration_finsh_flag
                                status = struct('code', 10, 'subCode', 0, 'errorName', 'Configuration error', 'message', 'STATUS_CONFIG_ERROR');
                            else
                                status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                                server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                            end
                            status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                            server.sender.WriteOpenIGTLinkStatusMessage(char(state), status); 
                        else
                            error_message = "Wrong command at this time.";
                        end
                    end
                end
            else
                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                % server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            end
            if command_recieved
                disp('Calibration finished');
                command_recieved = false;
            end                           
                idle_flag = true;
                state = "IDLE";        
                server.robot.set_robot_mode('idle');

        case "PLANNING"
            disp('Planning');
            set_mode_count = 0;
            fail_flag = false;
            id = split(name, '_');
            if ~robot_not_ready && calibration_finsh_flag
                server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
                % Set the robot into planning mode
                if ~strcmp(robot_mode, 'planning')
                    server.robot.set_robot_mode('planning');
                    robot_mode = server.robot.check_robot_mode();
                    
                    if ~strcmp(robot_mode, 'planning')
                        status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                        server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
                        error_message = "Start planning fail, check robot status";
                        disp(error_message);
                        fail_flag = true;
                    end
                end
                if ~fail_flag
                    planning_finsh_flag = true;
                    status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                    server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                end
            %Get into calibration without starting the robot
            elseif robot_not_ready
                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            elseif ~calibration_finsh_flag
                error_message = 'Robot not calibrated, calibrate the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            end
            if command_recieved
                disp('Already planned');
                idle_flag = true;
                state = "IDLE";
                command_recieved = false;
                server.robot.set_robot_mode('idle');
            end

        case "TARGETING"
            disp('Targeting');
            set_mode_count = 0;
            fail_flag = false;
            id = split(name, '_');
            if ~robot_not_ready && planning_finsh_flag
                server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
                % Set the robot into targeting mode
                if ~strcmp(robot_mode, 'targeting')
                    %try to set the robot mode in calibration and check the
                    %mode again

                    server.robot.set_robot_mode('targeting');
                    robot_mode = server.robot.check_robot_mode();
                    
                    if ~strcmp(robot_mode, 'targeting')
                        status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                        error_message = "Start targeting fail, check robot status";
                        disp(error_message);
                        fail_flag = true;
                    else
                        status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                    end
                    server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                    server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
                end
                if ~fail_flag
                    while ~targeting_finsh_flag
                        [name, type, data] = server.receiver.readMessage();
                        if strcmpi(type, 'STRING')
                            if strcmpi(data, 'CURRENT_POSITION')
                                robot_pose = server.robot.get_robot_current_pose();
                                server.sender.WriteOpenIGTLinkTransformMessage('CURRENT_POSITION', robot_pose);
                            else
                                % Need to make sure can return to other states
                                error_message = "Wrong command at this time.";
                                server.sender.WriteOpenIGTLinkStringMessage(char(name), char(error_message));
                            end
                        elseif strcmpi(type, 'TRANSFORM')
                            server.sender.WriteOpenIGTLinkTransformMessage(char("ACK_Transform"), data);
                            is_in_workspace = server.robot.check_target(data);
                            pause(0.1);
                            if ~is_in_workspace
                                status = struct('code', 10, 'subCode', 0, 'errorName', 'Configuration error', 'message', 'STATUS_CONFIG_ERROR');
                                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
                            else
                                status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                                server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
                                targeting_finsh_flag = true;
                            end                           
                        else
                            error_message = "Wrong type of message at this time.";
                            server.sender.WriteOpenIGTLinkStringMessage(char(name), char(error_message));
                        end
                    end
                    % cancel(pose_server);
                end
            %Get into calibration without starting the robot
            elseif robot_not_ready
                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            elseif ~planning_finsh_flag
                error_message = 'Target not planed, plan the target first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            end
            if command_recieved
                disp('Already targeted');
                idle_flag = true;
                state = "IDLE";
                command_recieved = false;
                server.robot.set_robot_mode('idle');
            end

        case "IDLE"
            if ~robot_not_ready
                disp('Idle');
                while idle_flag
                    [name, type, data] = server.receiver.readMessage();
                    if strcmpi(type, 'STRING')
                        disp(data);
                        if strcmpi(data, 'CURRENT_POSITION')
                            robot_pose = server.robot.get_robot_current_pose();
                            server.sender.WriteOpenIGTLinkTransformMessage('CURRENT_POSITION', robot_pose);
                            %pause(0.2);
                        elseif ismember(data, server.validCommands)
                            msg = "Exiting idle mode, and getting into " + data + "mode.";
                            disp(msg);
                            idle_flag = false;
                            command_recieved = true;
                            state = data;
                        else
                            error_message = "Unknown Command, Please check.";
                            disp(error_message);
                        end
                    else
                        error_message = "Wrong command at this time.";
                        disp(error_message);
                    end
                end
            else
                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
                idle_flag = false;
                command_recieved = false;
            end

        case "MOVE_TO_TARGET"
            disp('Scan & Move');
            fail_flag = false;
            id = split(name, '_');
            if ~robot_not_ready && targeting_finsh_flag
                server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
                % Set the robot into calibration mode
                if ~strcmp(robot_mode, 'move_to_goal')
                    server.robot.set_robot_mode('move_to_goal');
                    robot_mode = server.robot.check_robot_mode();
                    
                    if ~strcmp(robot_mode, 'move_to_goal')
                        status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                        error_message = "Start moving fail, check robot status";
                        disp(error_message);
                        fail_flag = true;
                    else
                        status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                    end
                    server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                    server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
                end
                if ~fail_flag
                    final_targeting_reached = false;
                    first_step_flag = true;
                    while ~final_targeting_reached
                        if open_loop
                            server.robot.move_to_end();
                            break
                        else
                            [name, type, data] = server.receiver.readMessage();
                            if strcmpi(type, 'STRING')
                                if strcmpi(data, 'CURRENT_POSITION')
                                    robot_pose = server.robot.get_robot_current_pose();
                                    server.sender.WriteOpenIGTLinkTransformMessage(char("CURRENT_POSITION"), robot_pose);
                                else
                                    error_message = "Wrong command at this time.";
                                    server.sender.WriteOpenIGTLinkStringMessage(char(name), char(error_message));
                                end
                            elseif strcmpi(type, 'TRANSFORM')
                                server.sender.WriteOpenIGTLinkStringMessage(char(name), char("ACK_NPSOE"));
                                pause(0.1);
                                if ~is_in_workspace
                                    status = struct('code', 10, 'subCode', 0, 'errorName', 'Configuration error', 'message', 'STATUS_CONFIG_ERROR');
                                    server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
                                    break
                                else
                                    if first_step_flag
                                        server.robot.set_entry_point(data);
                                        first_step_flag = false;
                                    end
                                    status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                                    server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
                                    server.robot.move_A_step(data);
                                    robot_pose = server.robot.get_robot_current_pose();
                                    server.sender.WriteOpenIGTLinkTransformMessage(char(name), robot_pose);
                                    final_targeting_reached = server.robot.is_target_reached;
                                end                           
                            else
                                error_message = "Wrong type of message at this time.";
                                server.sender.WriteOpenIGTLinkStringMessage(char(name), char(error_message));
                            end
                        end
                    end
                    if final_targeting_reached
                        msg = "Reached Final target.";
                    else
                        msg = "Target not reachable anymore.";
                    end
                    disp(msg)

                end
            %Get into calibration without starting the robot
            elseif robot_not_ready
                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            elseif ~calibration_finsh_flag
                error_message = 'Robot not calibrated, calibrate the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            elseif ~targeting_finsh_flag
                error_message = 'No target recieved, finish targeting the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            end
            if command_recieved
                disp('Already calibrated');
                idle_flag = true;
                state = "IDLE";
                command_recieved = false;
                server.robot.set_robot_mode('idle');
            end
        case "RETRACT_NEEDLE"
            disp("Retract needle to home pose")
            fail_flag = false;
            id = split(name, '_');
            if ~robot_not_ready
                server.sender.WriteOpenIGTLinkStringMessage(char("ACK_"+id(2)), char(state));
                status = struct('code', 1, 'subCode', 0, 'errorName', 'none', 'message', 'STATUS_OK');
                server.sender.WriteOpenIGTLinkStatusMessage(char("CURRENT_STATUS"), status);
                server.robot.RetractNeedle();
                server.sender.WriteOpenIGTLinkStatusMessage(char(state), status);
            else
                                error_message = 'Robot not start up, intialize the robot first!';
                disp(error_message);
                server.sender.WriteOpenIGTLinkStringMessage(char(name), error_message);
                status = struct('code', 13, 'subCode', 0, 'errorName', 'Device not ready', 'message', 'STATUS_NOT_READY');
                server.sender.WriteOpenIGTLinkStatusMessage(char(name), status);
            end
                       
        case "STOP"
            disp("Stop the robot and communication");
            server.robot.stop();
            msg = "Robot stopped";
            break
        case "EMERGENCY"
            disp("EMERGENCY STOP!");
            server.robot.stop();
            msg = "Estop pressed";
            server.disconnect()
            break
    end
        

end